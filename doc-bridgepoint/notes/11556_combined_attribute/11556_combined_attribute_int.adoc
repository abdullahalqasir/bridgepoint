= Combined Attribute Fix

xtUML Project Implementation Note

== 1 Abstract

In <<dr-1>>, the result of combining a base attribute with a referential results
in any formalizations made on the combined reference to have the datatype
defaulted to integer.

== 2 Introduction and Background

Combined referentials are restricted to a combination of base identifier 
attribute combined with a referential attribute, that resolves back to the same 
base, or a combination of referential attributes that resolve back to the same 
base attribute. This is done to constrain relationship loops and adds a benefit
of removing clutter from the class model.

The implementation of combined referentials in the OOAofOOA is all done in the
process models (OAL).

The process of combination involves making one attribute the root of the
combination and deleting the other attributes. All combinations are done as
referential attributes, so in the base and referential case, the base attribute
must be first migrated to referential.

== 3 Requirements

Formalizations on a combined referential must retain the datatype of the
referred to attribute.

== 4 Work Required

Determine how to set the datatype without having a base attribute, and add that
to the OAL where new referential attributes are created.

=== 4.1 Observations
Cause of datatype being set to integer is ReferentialAttribute.setDataType
doesn't find a base attribute. In the OAL, ReferentialAttribute.setDataType is 
only called from Attribute.migrateBaseToReferential, but it was observed to be
called during model loading as well.

Attribute.migrateBaseToReferential is only called in two places,
Attribute.combine_refs and ModelClass.newReferentialAttribute. The error occurs
in the call from ModelClass.newReferentialAttribute.

=== 4.2 Dead code

Attribute.migrateBaseToReferential performs a dispose of the base attribute as
it's first step. ReferentialAttribute.setDataType checks for the base attribute
as it's first step, and does nothing if no base attribute is found. This makes
the call to ReferentialAttribute.setDataType from
Attribute.migrateBaseToReferential "dead code".

=== 4.3 Fixing the issue

Remove the dead code in Attribute.migrateBaseToReferential.

In ModelClass.newReferentialAttribute, add a check for a missing base attribute,
and if the base attribute is missing, use the referred to attribute's datatype.

While Attribute.migrateBaseToReferential is also called from
Attribute.combine_refs, Attribute.combine_refs sets the datatype using the base
attribute's saved datatype, so no change is needed in Attribute.combine_refs.

== 5 Implementation Comments

It seems to me that the whole handling of combined referentials would be greatly
simplified, if it was added to the Subsystem class model in the OOAofOOA.

The deletion of the base attribute is a kludge, that is probably going to cause
other issues.

== 6 Unit Test

A new unit test would be added to CombineSplitReferentialsTestGenerics.java in
the bptest repository to check the datatype after formalizing using a combined
identifier.

== 7 User Documentation

== 8 Code Changes

- fork/repository:  lwriemen/bridgepoint
- branch:  11556-merge-referential-datatype-loss

----
 Put the file list here
----

== 9 Document References

. [[dr-1]] https://support.onefact.net/issues/11556[11556 - Merging referentials causes datatype to be lost]

---

This work is licensed under the Creative Commons CC0 License

---
